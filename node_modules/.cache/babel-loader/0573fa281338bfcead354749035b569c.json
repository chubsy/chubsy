{"ast":null,"code":"'use strict';\n\nvar Queue = require('tinyqueue');\n\nmodule.exports = polylabel;\nmodule.exports.default = polylabel;\n\nfunction polylabel(polygon, precision, debug) {\n  precision = precision || 1.0; // find the bounding box of the outer ring\n\n  var minX, minY, maxX, maxY;\n\n  for (var i = 0; i < polygon[0].length; i++) {\n    var p = polygon[0][i];\n    if (!i || p[0] < minX) minX = p[0];\n    if (!i || p[1] < minY) minY = p[1];\n    if (!i || p[0] > maxX) maxX = p[0];\n    if (!i || p[1] > maxY) maxY = p[1];\n  }\n\n  var width = maxX - minX;\n  var height = maxY - minY;\n  var cellSize = Math.min(width, height);\n  var h = cellSize / 2; // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n\n  var cellQueue = new Queue(null, compareMax);\n  if (cellSize === 0) return [minX, minY]; // cover polygon with initial cells\n\n  for (var x = minX; x < maxX; x += cellSize) {\n    for (var y = minY; y < maxY; y += cellSize) {\n      cellQueue.push(new Cell(x + h, y + h, h, polygon));\n    }\n  } // take centroid as the first best guess\n\n\n  var bestCell = getCentroidCell(polygon); // special case for rectangular polygons\n\n  var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n  if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n  var numProbes = cellQueue.length;\n\n  while (cellQueue.length) {\n    // pick the most promising cell from the queue\n    var cell = cellQueue.pop(); // update the best cell if we found a better one\n\n    if (cell.d > bestCell.d) {\n      bestCell = cell;\n      if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n    } // do not drill down further if there's no chance of a better solution\n\n\n    if (cell.max - bestCell.d <= precision) continue; // split the cell into four cells\n\n    h = cell.h / 2;\n    cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n    cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n    cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n    cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n    numProbes += 4;\n  }\n\n  if (debug) {\n    console.log('num probes: ' + numProbes);\n    console.log('best distance: ' + bestCell.d);\n  }\n\n  return [bestCell.x, bestCell.y];\n}\n\nfunction compareMax(a, b) {\n  return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n  this.x = x; // cell center x\n\n  this.y = y; // cell center y\n\n  this.h = h; // half the cell size\n\n  this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n\n  this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n} // signed distance from point to polygon outline (negative if point is outside)\n\n\nfunction pointToPolygonDist(x, y, polygon) {\n  var inside = false;\n  var minDistSq = Infinity;\n\n  for (var k = 0; k < polygon.length; k++) {\n    var ring = polygon[k];\n\n    for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n      var a = ring[i];\n      var b = ring[j];\n      if (a[1] > y !== b[1] > y && x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0]) inside = !inside;\n      minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n    }\n  }\n\n  return (inside ? 1 : -1) * Math.sqrt(minDistSq);\n} // get polygon centroid\n\n\nfunction getCentroidCell(polygon) {\n  var area = 0;\n  var x = 0;\n  var y = 0;\n  var points = polygon[0];\n\n  for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n    var a = points[i];\n    var b = points[j];\n    var f = a[0] * b[1] - b[0] * a[1];\n    x += (a[0] + b[0]) * f;\n    y += (a[1] + b[1]) * f;\n    area += f * 3;\n  }\n\n  if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n  return new Cell(x / area, y / area, 0, polygon);\n} // get squared distance from a point to a segment\n\n\nfunction getSegDistSq(px, py, a, b) {\n  var x = a[0];\n  var y = a[1];\n  var dx = b[0] - x;\n  var dy = b[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = b[0];\n      y = b[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = px - x;\n  dy = py - y;\n  return dx * dx + dy * dy;\n}","map":{"version":3,"sources":["/Users/chloeshiau/Pictures/chubsy/node_modules/polylabel/index.js"],"names":["Queue","require","module","exports","polylabel","default","polygon","precision","debug","minX","minY","maxX","maxY","i","length","p","width","height","cellSize","Math","min","h","cellQueue","compareMax","x","y","push","Cell","bestCell","getCentroidCell","bboxCell","d","numProbes","cell","pop","console","log","round","max","a","b","pointToPolygonDist","SQRT2","inside","minDistSq","Infinity","k","ring","len","j","getSegDistSq","sqrt","area","points","f","px","py","dx","dy","t"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Queue = require('tinyqueue');\n\nmodule.exports = polylabel;\nmodule.exports.default = polylabel;\n\nfunction polylabel(polygon, precision, debug) {\n    precision = precision || 1.0;\n\n    // find the bounding box of the outer ring\n    var minX, minY, maxX, maxY;\n    for (var i = 0; i < polygon[0].length; i++) {\n        var p = polygon[0][i];\n        if (!i || p[0] < minX) minX = p[0];\n        if (!i || p[1] < minY) minY = p[1];\n        if (!i || p[0] > maxX) maxX = p[0];\n        if (!i || p[1] > maxY) maxY = p[1];\n    }\n\n    var width = maxX - minX;\n    var height = maxY - minY;\n    var cellSize = Math.min(width, height);\n    var h = cellSize / 2;\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    var cellQueue = new Queue(null, compareMax);\n\n    if (cellSize === 0) return [minX, minY];\n\n    // cover polygon with initial cells\n    for (var x = minX; x < maxX; x += cellSize) {\n        for (var y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygon));\n        }\n    }\n\n    // take centroid as the first best guess\n    var bestCell = getCentroidCell(polygon);\n\n    // special case for rectangular polygons\n    var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n    if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n\n    var numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        var cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log('num probes: ' + numProbes);\n        console.log('best distance: ' + bestCell.d);\n    }\n\n    return [bestCell.x, bestCell.y];\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.x = x; // cell center x\n    this.y = y; // cell center y\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(x, y, polygon) {\n    var inside = false;\n    var minDistSq = Infinity;\n\n    for (var k = 0; k < polygon.length; k++) {\n        var ring = polygon[k];\n\n        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            var a = ring[i];\n            var b = ring[j];\n\n            if ((a[1] > y !== b[1] > y) &&\n                (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n        }\n    }\n\n    return (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    var area = 0;\n    var x = 0;\n    var y = 0;\n    var points = polygon[0];\n\n    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        var a = points[i];\n        var b = points[j];\n        var f = a[0] * b[1] - b[0] * a[1];\n        x += (a[0] + b[0]) * f;\n        y += (a[1] + b[1]) * f;\n        area += f * 3;\n    }\n    if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n    return new Cell(x / area, y / area, 0, polygon);\n}\n\n// get squared distance from a point to a segment\nfunction getSegDistSq(px, py, a, b) {\n\n    var x = a[0];\n    var y = a[1];\n    var dx = b[0] - x;\n    var dy = b[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = b[0];\n            y = b[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n"]},"metadata":{},"sourceType":"script"}